-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Jezyk.Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Jezyk.Abs

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: Jezyk.Abs.Ident -> Result
transIdent x = case x of
  Jezyk.Abs.Ident string -> failure x

transVar :: Jezyk.Abs.Var -> Result
transVar x = case x of
  Jezyk.Abs.VId ident -> failure x
  Jezyk.Abs.VAt ident expr -> failure x

transArg :: Jezyk.Abs.Arg -> Result
transArg x = case x of
  Jezyk.Abs.AId ident -> failure x
  Jezyk.Abs.ASeq ident arg -> failure x

transStmt :: Jezyk.Abs.Stmt -> Result
transStmt x = case x of
  Jezyk.Abs.SCall ident -> failure x
  Jezyk.Abs.SCallA ident arg -> failure x
  Jezyk.Abs.SAssgn var expr -> failure x
  Jezyk.Abs.SAssgnF var ident -> failure x
  Jezyk.Abs.SAssgnFA var ident arg -> failure x
  Jezyk.Abs.SDel expr ident -> failure x
  Jezyk.Abs.SIfte expr stmt1 stmt2 -> failure x
  Jezyk.Abs.SIfend expr stmt -> failure x
  Jezyk.Abs.SWhile expr stmt -> failure x
  Jezyk.Abs.SFor ident expr1 expr2 stmt -> failure x
  Jezyk.Abs.SForKeys ident1 ident2 stmt -> failure x
  Jezyk.Abs.SForVals ident1 ident2 stmt -> failure x
  Jezyk.Abs.SForPairs ident1 ident2 ident3 stmt -> failure x
  Jezyk.Abs.SPrint ident -> failure x
  Jezyk.Abs.SBlock decl stmt -> failure x
  Jezyk.Abs.STry stmt1 stmt2 -> failure x
  Jezyk.Abs.SSeq stmt1 stmt2 -> failure x

transExpr :: Jezyk.Abs.Expr -> Result
transExpr x = case x of
  Jezyk.Abs.EAnd expr1 expr2 -> failure x
  Jezyk.Abs.EOr expr1 expr2 -> failure x
  Jezyk.Abs.ENot expr -> failure x
  Jezyk.Abs.EEq expr1 expr2 -> failure x
  Jezyk.Abs.ELt expr1 expr2 -> failure x
  Jezyk.Abs.ELeq expr1 expr2 -> failure x
  Jezyk.Abs.EGt expr1 expr2 -> failure x
  Jezyk.Abs.EGeq expr1 expr2 -> failure x
  Jezyk.Abs.ENeq expr1 expr2 -> failure x
  Jezyk.Abs.ETrue -> failure x
  Jezyk.Abs.EFalse -> failure x
  Jezyk.Abs.ECheck expr ident -> failure x
  Jezyk.Abs.EPlus expr1 expr2 -> failure x
  Jezyk.Abs.EMinus expr1 expr2 -> failure x
  Jezyk.Abs.EMul expr1 expr2 -> failure x
  Jezyk.Abs.EDiv expr1 expr2 -> failure x
  Jezyk.Abs.ENeg expr -> failure x
  Jezyk.Abs.ENum integer -> failure x
  Jezyk.Abs.EVar ident -> failure x
  Jezyk.Abs.Etern expr1 expr2 expr3 -> failure x

transType :: Jezyk.Abs.Type -> Result
transType x = case x of
  Jezyk.Abs.TBool -> failure x
  Jezyk.Abs.TInt -> failure x

transCType :: Jezyk.Abs.CType -> Result
transCType x = case x of
  Jezyk.Abs.CTArray integer type_ -> failure x
  Jezyk.Abs.CTDict type_ -> failure x

transADecl :: Jezyk.Abs.ADecl -> Result
transADecl x = case x of
  Jezyk.Abs.ADId ident type_ -> failure x
  Jezyk.Abs.ADSeq ident type_ adecl -> failure x

transFDecl :: Jezyk.Abs.FDecl -> Result
transFDecl x = case x of
  Jezyk.Abs.FDVoid -> failure x
  Jezyk.Abs.FDRet ident type_ -> failure x
  Jezyk.Abs.FDArg adecl -> failure x
  Jezyk.Abs.FDFull adecl ident type_ -> failure x

transDecl :: Jezyk.Abs.Decl -> Result
transDecl x = case x of
  Jezyk.Abs.DSimple ident type_ -> failure x
  Jezyk.Abs.DComplex ident ctype -> failure x
  Jezyk.Abs.DFunction ident fdecl stmt -> failure x
  Jezyk.Abs.DSeq decl1 decl2 -> failure x
